<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quine PWA</title>

<!-- PWA manifest + theme -->
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#111111">

<!-- iOS Home-Screen niceties -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon-180.png">

<style>
  :root { color-scheme: light dark; }
  html, body { height: 100%; }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    display: grid; place-items: center; padding: 1rem;
  }
  .app {
    width: min(900px, 100%); min-height: 60vh; border: 1px solid #ccc; border-radius: 12px;
    padding: 1rem; overflow: auto; background: Canvas; color: CanvasText;
  }
  .hint { opacity: .7; font-size: .9rem; margin-top: .5rem; }
  button { font: inherit; padding: .5rem .8rem; border-radius: 8px; }
  textarea {
    width: 100%; height: 30vh; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
  }
  .row { display: flex; gap: .5rem; flex-wrap: wrap; }
</style>
</head>
<body>
  <div class="app">
    <h1>Quine PWA</h1>
    <p>This is your PWA shell. Paste your Markdown/ABC/LilyPond content below. Add your renderer/worker as needed.</p>

    <div class="row">
      <button id="save">Save</button>
      <button id="load">Load</button>
      <button id="clear">Clear</button>
    </div>

    <textarea id="editor" placeholder="Type here…"></textarea>
    <div class="hint">
      iOS install: in Safari → Share → <b>Add to Home Screen</b>.
      Try offline: Airplane Mode → launch from the icon → your app still opens.
    </div>
    <pre id="log"></pre>
  </div>

<script>
  // --- GitHub Pages base detection (works in root or /<repo>/) ---
  const pathParts = location.pathname.split("/").filter(Boolean);
  const isProjectPage = location.hostname.endsWith(".github.io") && pathParts.length >= 1;
  const BASE = isProjectPage ? ("/" + pathParts[0] + "/") : "/";

  // --- Register Service Worker (HTTPS required; GitHub Pages is HTTPS) ---
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register(BASE + "sw.js")
        .catch(err => console.warn("SW registration failed:", err));
    });
  }

  /* ============================================================
     ROBUST STATE STORAGE (IndexedDB with localStorage fallback)
     ============================================================ */
  const APP_KEY   = (location.pathname.replace(/\/+$/,'') || '/');  // namespace by path
  const STATE_KEY = `${APP_KEY}::editorState`;

  const DB_NAME = 'quine-db';
  const STORE   = 'states';

  function idbOpen(){
    return new Promise((res, rej) => {
      const r = indexedDB.open(DB_NAME, 1);
      r.onupgradeneeded = () => {
        const db = r.result;
        if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
      };
      r.onsuccess = () => res(r.result);
      r.onerror   = () => rej(r.error);
    });
  }
  function idbGet(k){ return idbOpen().then(db => new Promise((res, rej)=>{
    const t = db.transaction(STORE, 'readonly');
    const s = t.objectStore(STORE).get(k);
    s.onsuccess = () => res(s.result ?? null);
    s.onerror   = () => rej(s.error);
  }));}
  function idbSet(k,v){ return idbOpen().then(db => new Promise((res, rej)=>{
    const t = db.transaction(STORE, 'readwrite');
    const s = t.objectStore(STORE).put(v, k);
    s.onsuccess = () => res(true);
    s.onerror   = () => rej(s.error);
  }));}
  function idbDel(k){ return idbOpen().then(db => new Promise((res, rej)=>{
    const t = db.transaction(STORE, 'readwrite');
    const s = t.objectStore(STORE).delete(k);
    s.onsuccess = () => res(true);
    s.onerror   = () => rej(s.error);
  }));}

  function lsGet(k){ try { return Promise.resolve(localStorage.getItem(k)); } catch { return Promise.resolve(null); } }
  function lsSet(k,v){ try { localStorage.setItem(k,v); return Promise.resolve(true); } catch { return Promise.resolve(false); } }
  function lsDel(k){ try { localStorage.removeItem(k); return Promise.resolve(true); } catch { return Promise.resolve(false); } }

  async function loadState(){
    if ('indexedDB' in window) { try { const v = await idbGet(STATE_KEY); if (v != null) return v; } catch {} }
    return await lsGet(STATE_KEY);
  }
  async function saveState(text){
    if ('indexedDB' in window) { try { await idbSet(STATE_KEY, text); return true; } catch {} }
    return await lsSet(STATE_KEY, text);
  }
  async function clearState(){
    if ('indexedDB' in window) { try { await idbDel(STATE_KEY); } catch {} }
    await lsDel(STATE_KEY);
  }

  // ---------- One-time migration from old Cache API storage ----------
  (async () => {
    try {
      if (!('caches' in window)) return;
      const oldCache = await caches.open('quine-store-v1');
      // If you used a different key, adjust below:
      const oldReq = new Request('quine://content', { method: 'GET' });
      const resp = await oldCache.match(oldReq);
      if (resp) {
        const text = await resp.text();
        await saveState(text);
        await oldCache.delete(oldReq);
        log('Migrated previous cached state → IndexedDB');
      }
    } catch {}
  })();
  // -------------------------------------------------------------------

  // --- Wire up UI ---
  const editor  = document.getElementById('editor');
  const logEl   = document.getElementById('log');
  const saveBtn = document.getElementById('save');
  const loadBtn = document.getElementById('load');
  const clearBtn= document.getElementById('clear');

  function log(msg) {
    logEl.textContent = new Date().toLocaleTimeString() + " -- " + msg + "\n" + logEl.textContent;
  }

  (async () => {
    const existing = await loadState();
    if (existing != null) { editor.value = existing; log('Restored from storage'); }
  })();

  let debounce;
  editor.addEventListener('input', () => {
    clearTimeout(debounce);
    debounce = setTimeout(async () => {
      await saveState(editor.value);
      log('Autosaved');
    }, 400);
  });

  saveBtn.addEventListener('click', async () => { await saveState(editor.value); log('Saved'); });
  loadBtn.addEventListener('click', async () => {
    const v = await loadState();
    editor.value = v ?? '';
    log(v != null ? 'Loaded' : 'Nothing saved yet');
  });
  clearBtn.addEventListener('click', async () => { await clearState(); log('Cleared'); });
</script>
</body>
</html>